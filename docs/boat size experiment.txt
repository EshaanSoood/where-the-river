Boat Size Responsiveness – Brainstorm (2025-11-04)

Goal
Make GLB boat scale feel proportional to the arc it sails without touching runtime code yet.

Option 1 – Arc Length Buckets (low compute)
• Derive a geodesic length per arc when we already build Catmull-Rom control points. A single haversine distance per link adds ~O(E) scalar ops during hydration (~hundreds today). 
• Classify into 3–4 buckets (short / medium / long / epic) and map each to a fixed scale multiplier (e.g., 0.85×, 1×, 1.15×, 1.3×). Store the bucket on the arc metadata so spawnBoats can read it without recomputation.
• Compute impact: negligible; one extra float per arc and a couple comparisons on spawn.

Option 2 – Waypoint Span Heuristic (low-medium compute)
• We already build Catmull-Rom waypoints. Measure total chord length by summing |p[i] – p[i-1]| before generating the curve.
• Normalize by Earth radius to approximate travel time, then map to scale. Because this runs once per boat spawn, cost is O(W) with W ≈ 8–16 waypoints.
• Cache the resulting scale on the boat instance so we never touch it again. Adds maybe microseconds per spawn; invisible to FPS.

Option 3 – Camera Distance Modulation (medium compute)
• Combine Option 1 or 2 with a per-frame multiplier based on camera distance to the nearest arc midpoint. This keeps boats readable when user zooms way out.
• Requires projecting midpoint once per frame for active boats (~1–2) → trivial overhead but introduces per-frame math (vector dot + inverse). Still well within budget (<0.01ms/frame).

Option 4 – Screen-Space Length Estimation (high compute, probably skip)
• Project both arc endpoints each frame and measure screen distance to drive boat scaling dynamically.
• Gives perfect visual proportionality but adds matrix multiplications + perspective divide per frame, per boat. With throttling it might still be fine, yet it complicates overlay scheduling and risks jank on low-end devices. Not recommended unless we see a real UX need.

Option 5 – Chain Depth Based Scaling (low compute, stylistic)
• Tie boat size to referral depth or boats_total instead of physical arc length. Data already available in `users_referrals` payload; no geometry math needed.
• Good storytelling (deeper chains → bigger flagship) but may look odd if a short arc has a large boat. Could be combined with Option 1 as a clamp (min/max).

Implementation Notes
• Any of Options 1/2 should reuse existing deterministic caches so scale stays stable across sessions.
• Store the scale factor alongside arc metadata to avoid recalculations during boatRespawn / GLB loading.
• Keep scale boundaries conservative (±20–30%) to avoid clipping or readjusting hitboxes.

Next Steps
1. Prototype Option 1 inside the arc builder, dump scale values to console to verify distribution.
2. If visuals benefit, thread the stored scale into `spawnBoatsForIdentity` and `ensureGuestBoats`.
3. Consider pairing with Option 3 for zoom responsiveness if QA reports readability issues on wide zoom ranges.


Closest-Country Edge Case (2025-11-04)
Problem
Guest boats riding super-short arcs (inviter ⇄ invitee in same country) barely move; current scale makes them look like they’re jittering in place.

Targeted Fix Concept
• Detect “short hop” arcs via simple angular distance threshold during existing geodesic calculation (e.g., < ~250 km ≈ 0.04 radians). No new data structures.
• When flagged, shrink boat scale only for that arc (e.g., ×0.6) and optionally stretch travel duration so motion stays readable.
• As a visual assist, bias Catmull-Rom control points upward slightly (raise altitude multiplier from 1.07 → 1.12 just for these arcs) so the boat visibly travels a mini-loop instead of hugging the same spot.

Compute Impact
• One extra distance comparison per arc (already doing haversine if we adopt Option 1). Effectively zero cost.
• Boat spawn path still reuses same waypoint list; stretching duration adds no GPU work.

Implementation Touchpoints
1. During arc build: store `isShortHop` flag alongside metadata.
2. In `ensureGuestBoats` / `spawnBoatsForIdentity`: if `isShortHop`, apply reduced scale + longer duration (e.g., +30%).
3. Optional: adjust curve control altitude only for flagged arcs to exaggerate motion without affecting long routes.

Advantage
• Minimal code footprint, no global scale system needed.
• Solves the “bouncing boat” perception for intra-country edges while leaving other arcs unaffected.

